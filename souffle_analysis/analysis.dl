#include "analysis-input.dl"
#include "analysis-patterns.dl"
#include "util-macros.dl"
#include "util-graph.dl"
#include "util-lists.dl"
//#include "analysis-contexts.dl"
//#include "contexts/callstack-context.dl"

//.init ctxProvider = FullContext

// follows: a unit depends on another one which is closer to the leaves of the tree
.decl followsStep(element: Element, previousElement: Element)
followsStep(dependent, independent) :-
    (
        absDD(dependent, independent);
        absTD(dependent, independent);
        absTT(dependent, independent);
        appDD(dependent, independent);
        appTD(dependent, independent);
        argument(dependent, independent, _);
        bind(dependent, _, independent);
        callProc(dependent, independent);
        condBind(dependent, independent, _);
        dataCase(dependent, independent, _, _);
        dataCase(dependent, _, independent, _);
        dataCase(dependent, _, _, independent);
        jump(dependent, independent);
        keyArgument(dependent, independent, _);
        mapType(dependent, _, independent);
        pickData(dependent, independent, _);
        pickProc(dependent, independent);
        plan(dependent, independent, _);
        procCase(dependent, independent, _);
        procCase(dependent, _, independent);
        save(dependent, _, independent);
        send(dependent, independent)
    ).
.output followsStep

.decl follows(dependent: Unit, independent: Unit)
follows(dependent, independent) :- followsStep(dependent, independent).
follows(dependent, independent) :- followsStep(dependent, intermediate), follows(intermediate, independent).

.output follows

.decl transfer(transfer: Unit, argument: Unit, parameter: Unit)
transfer(transfer, argument, parameter):-
    appDD(transfer, _),
    argument(transfer, argument, index),
    argument(absDDId, parameter, index),
    follows(transfer, absDDId),
    absDD(absDDId, _),
    cApp = count : {follows(transfer, intermediate), appDD(intermediate, _) ,follows(intermediate, absDDId)},
    cAbs = count : {follows(transfer, intermediate), absDD(intermediate, _) ,follows(intermediate, absDDId)},
    cApp = cAbs.

.output transfer


.type Context = [u: Unit, c: Context]
.type ElementInContext = [element: Element, context: Context]

.decl contextForInit(element: Element, context : Context)
contextForInit(transitionId, nil) :- transition(transitionId).

.decl context(context: Context)
.decl executionState(element: Element, context: Context)
context(context), executionState(element, context) :- 
    transition(element), contextForInit(element, context).

// if the node does not depend on an appDD, just propagate the context
context(context) ,executionState(elementId, context) :-
    followsStep(dep, elementId),
    !planApp(dep),
    executionState(dep, context).

context(context) ,executionState(elementId, context) :-
    argument(dep, elementId, _),
    planApp(dep),
    executionState(dep, context).
//check two_calls.json
// If the node depends on an appDD which is part of the plan then add a context taking the context
// of the proc. We do this since a planAppDD my be used later by another appDD. Then we will add the context twice,
// once for the calculation of the value of the appDD and once when the value is used as an argument.
context(context), executionState(elementId, contextAppDD) :-
    followsStep(dep, elementId),
    plan(procId, dep, _),
    appDD(dep, elementId),
    contextAppDD = [dep, context],
    executionState(procId, context).

.decl elementInContext(elemCtx: ElementInContext, element: Element, context: Context)
elementInContext([element, context], element, context):-
    executionState(element, context).

.decl planApp(unitId: Unit)
planApp(unitId):-
    appDD(unitId, _), plan(_, unitId, _).

planApp(unitId):-
    appTD(unitId, _), plan(_, unitId, _).

.output planApp
.init contexts = ListOps<Element, Context>

.decl printExecutionState(elementId: Element, strCtx: symbol)
printExecutionState(elementId, strCtx):-
    executionState(elementId, context),
    contextToString(context, strCtx).

.decl contextToString(context: Context, str: symbol)
contextToString(nil, "").
contextToString([c, cRest], STR_JOIN(c, ",", rest)) :-
    context([c, cRest]),
    contextToString(cRest, rest).

.output printExecutionState
.output executionState


.decl dependsOnStep(elemCtx: ElementInContext, prevCtx: ElementInContext)
dependsOnStep(elemCtx, elemCtx) :-
    elementInContext(elemCtx, _, _).

dependsOnStep(elemCtx, prevCtx) :-
    followsStep(elem, prev),
    elementInContext(elemCtx, elem, ctx),
    elementInContext(prevCtx, prev, ctx).

dependsOnStep(elemCtx, prevCtx) :-
    followsStep(elem, prev),
    followsContext(ctxElem, ctxPrev),
    elementInContext(elemCtx, elem, ctxElem),
    elementInContext(prevCtx, prev, ctxPrev).

.output dependsOnStep

.decl instrMayDependOn(instCtx: ElementInContext, condCtx: ElementInContext)
instrMayDependOn(instCtx, condCtx) :-
    pickProc(pickProcId, condId),
    elementInContext(condCtx, condId, _),
    argument(pickProcId, pickCaseId, _),
    elementInContext(pickCaseCtx, pickCaseId, _),
    dependsOn(pickCaseCtx, instCtx).

.output instrMayDependOn


.decl printDependsOnStep(elem: Element, ctxStr: symbol, prevElem: Element, prevCtxStr: symbol)
printDependsOnStep(elem, ctxStr, prevElem, prevCtxStr) :-
    dependsOnStep(elemCtx, prevElemCtx),
    elementInContext(elemCtx, elem, ctx),
    contextToString(ctx, ctxStr),
    elementInContext(prevElemCtx, prevElem, prevCtx),
    contextToString(prevCtx, prevCtxStr).

.output printDependsOnStep


.decl dependsOn(elemCtx: ElementInContext, prevCtx: ElementInContext)
dependsOn(elemCtx, prevCtx) :- dependsOnStep(elemCtx, prevCtx).
dependsOn(elemCtx, prevCtx) :- dependsOnStep(elemCtx, intermediateCtx), dependsOn(intermediateCtx, prevCtx).

.output dependsOn

.decl followsContext(ctxPrev: Context, ctx: Context)
followsContext(ctxPrev, ctx) :-
    context(ctx),
    context(ctxPrev),
    [c, previousCtx] = ctx,
    previousCtx = ctxPrev.

.output followsContext

.decl printElementInContext(elemCtx: ElementInContext, elem: Element, str: symbol)
printElementInContext(elemCtx, elem, str) :-
    elementInContext(elemCtx, elem, ctx),
    contextToString(ctx, str).

.output printElementInContext


//.decl followsPlan(nextUnitPlan: Unit, prevUnitPlan: Unit)
//followsPlan(nextUnitPlan, prevUnitPlan) :-
    //plan(procId, nextUnitPlan, nextIndex),
    //plan(procId, prevUnitPlan, previousIndex),
    //nextIndex > previousIndex.
