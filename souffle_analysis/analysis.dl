#include "analysis-input.dl"
#include "analysis-patterns.dl"
#include "util-macros.dl"
#include "util-graph.dl"
#include "util-lists.dl"
//#include "analysis-contexts.dl"
//#include "contexts/callstack-context.dl"

//.init ctxProvider = FullContext

// DependsOn: a unit depends on another one which is closer to the leaves of the tree
.decl dependsOnStep(element: Element, previousElement: Element)
dependsOnStep(dependent, independent) :-
    (
        absDD(dependent, independent);
        absTD(dependent, independent);
        absTT(dependent, independent);
        appDD(dependent, independent);
        appTD(dependent, independent);
        argument(dependent, independent, _);
        bind(dependent, _, independent);
        callProc(dependent, independent);
        condBind(dependent, independent, _);
        dataCase(dependent, independent, _, _);
        dataCase(dependent, _, independent, _);
        dataCase(dependent, _, _, independent);
        jump(dependent, independent);
        keyArgument(dependent, independent, _);
        mapType(dependent, _, independent);
        pickData(dependent, independent, _);
        pickProc(dependent, independent);
        plan(dependent, independent, _);
        procCase(dependent, independent, _);
        procCase(dependent, _, independent);
        save(dependent, _, independent);
        send(dependent, independent)
    ).
.output dependsOnStep

.decl dependsOn(dependent: Unit, independent: Unit)
dependsOn(dependent, independent) :- dependsOnStep(dependent, independent).
dependsOn(dependent, independent) :- dependsOnStep(dependent, intermediate), dependsOn(intermediate, independent).

.output dependsOn

.decl transfer(transfer: Unit, argument: Unit, parameter: Unit)
transfer(transfer, argument, parameter):-
    appDD(transfer, _),
    argument(transfer, argument, index),
    argument(absDDId, parameter, index),
    dependsOn(transfer, absDDId),
    absDD(absDDId, _),
    cApp = count : {dependsOn(transfer, intermediate), appDD(intermediate, _) ,dependsOn(intermediate, absDDId)},
    cAbs = count : {dependsOn(transfer, intermediate), absDD(intermediate, _) ,dependsOn(intermediate, absDDId)},
    cApp = cAbs.

.output transfer


.type Context = [u: Unit, c: Context]
.type ElementInContext = [element: Element, context: Context]

.decl contextForInit(element: Element, context : Context)
contextForInit(transitionId, nil) :- transition(transitionId).

.decl context(context: Context)
.decl executionState(element: Element, context: Context)
context(context), executionState(element, context) :- 
    transition(element), contextForInit(element, context).

// if the node does not depend on an appDD, just propagate the context
context(context) ,executionState(elementId, context) :-
    dependsOnStep(dep, elementId),
    !planApp(dep),
    executionState(dep, context).

//check two_calls.json
// If the node depends on an appDD which is part of the plan then add a context taking the context
// of the proc. We do this since a planAppDD my be used later by another appDD. Then we will add the context twice,
// once for the calculation of the value of the appDD and once when the value is used as an argument.
context(context), executionState(elementId, contextAppDD) :-
    dependsOnStep(dep, elementId),
    plan(procId, dep, _),
    appDD(dep, elementId),
    contextAppDD = [dep, context],
    executionState(procId, context).

.decl planApp(unitId: Unit)
planApp(unitId):-
    appDD(unitId, _), plan(_, unitId, _).

planApp(unitId):-
    appTD(unitId, _), plan(_, unitId, _).

.output planApp
.init contexts = ListOps<Element, Context>

.decl printExecutionState(elementId: Element, strCtx: symbol)
printExecutionState(elementId, strCtx):-
    executionState(elementId, context),
    contextToString(context, strCtx).

.decl contextToString(context: Context, str: symbol)
contextToString(nil, "").
contextToString([c, cRest], STR_JOIN(c, ",", rest)) :-
    context([c, cRest]),
    contextToString(cRest, rest).

.decl contextToLength(context: Context, n: number)
contextToLength(nil, 0).
contextToLength([c, cRest], n+1):-
    context([c, cRest]),
    contextToLength(cRest, n).


.output printExecutionState
.output executionState







//.decl followsPlan(nextUnitPlan: Unit, prevUnitPlan: Unit)
//followsPlan(nextUnitPlan, prevUnitPlan) :-
    //plan(procId, nextUnitPlan, nextIndex),
    //plan(procId, prevUnitPlan, previousIndex),
    //nextIndex > previousIndex.
