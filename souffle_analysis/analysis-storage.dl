.comp StorageAnalysis {

    /**
    Associates a program element in a context with
    all storage mutations that may affect the element
    */
    .decl precedingStore(elem: ctxProvider.ElementInContext, elemStore: ctxProvider.ElementInContext)

    precedingStore(storeCtx, storeCtx) :-
        save(storeUnit, _, _),
        ctxProvider.elementInContext(storeCtx, storeUnit, _).

    precedingStore(storeCtx, prevStoreCtx) :-
        save(storeUnit, field, _),
        plans.nextPlannedElement(storeCtx, prevStoreCtx),
        ctxProvider.elementInContext(storeCtx, storeUnit, _),
        ctxProvider.elementInContext(prevStoreCtx, otherStoreUnit, _),
        save(otherStoreUnit, field2, _),
        field != field2.

    precedingStore(nextPlanCtx, storeCtx) :-
        plan(_, nextPlan, _),
        !save(nextPlan, _, _),
        ctxProvider.elementInContext(nextPlanCxt, nextPlan, _),
        (
            plans.nextPlannedElement(nextPlanCtx, prevPlanCtx); 
            plans.maybeNextPlannedElement(nextPlanCtx, prevPlanCtx)
        ),
        precedingStore(prevPlanCtx, storeCtx).

    .output precedingStore
}