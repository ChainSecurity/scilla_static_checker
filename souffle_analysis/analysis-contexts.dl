#include "util-lists.dl"

.comp ContextProvider {

    .type Context = [u: Unit, c: Context]
    .type ElementInContext = [element: Element, context: Context]

    .decl contextForInit(element: Element, context : Context)
    contextForInit(transitionId, nil) :- transition(transitionId).

    .decl context(context: Context)
    .decl executionState(element: Element, context: Context)
    context(context), executionState(element, context) :- 
        transition(element), contextForInit(element, context).

    // if the node does not depend on an appDD, just propagate the context
    context(context) ,executionState(elementId, context) :-
        followsStep(dep, elementId),
        !planApp(dep),
        executionState(dep, context).

    context(context) ,executionState(elementId, context) :-
        argument(dep, elementId, _),
        //planApp(dep),
        executionState(dep, context).

    //check two_calls.json
    // If the node depends on an appDD which is part of the plan then add a context taking the context
    // of the proc. We do this since a planAppDD my be used later by another appDD. Then we will add the context twice,
    // once for the calculation of the value of the appDD and once when the value is used as an argument.
    context(context), executionState(elementId, contextAppDD) :-
        followsStep(dep, elementId),
        plan(procId, dep, _),
        appDD(dep, elementId),
        contextAppDD = [dep, context],
        executionState(procId, context).

    .decl elementInContext(elemCtx: ElementInContext, element: Element, context: Context)
    elementInContext([element, context], element, context):-
        executionState(element, context).

    .decl printExecutionState(elementId: Element, strCtx: symbol)
    printExecutionState(elementId, strCtx):-
        executionState(elementId, context),
        contextToString(context, strCtx).

    .decl contextToString(context: Context, str: symbol)
    contextToString(nil, "").
    contextToString([c, cRest], STR_JOIN(c, ",", rest)) :-
        context([c, cRest]),
        contextToString(cRest, rest).

    .output printExecutionState
    .output executionState

    .decl followsContext(ctxPrev: Context, ctx: Context)
    followsContext(ctxPrev, ctx) :-
        context(ctx),
        context(ctxPrev),
        [c, previousCtx] = ctx,
        previousCtx = ctxPrev.

    .output followsContext

    .decl printElementInContext(elemCtx: ElementInContext, elem: Element, str: symbol)
    printElementInContext(elemCtx, elem, str) :-
        elementInContext(elemCtx, elem, ctx),
        contextToString(ctx, str).

    .output printElementInContext
}

#include "analysis-contexts-macros.dl"